<template>
  <div class="histogram-legend-container" ref="container"></div>
</template>

<script lang="ts">
import { defineComponent, ref, PropType, onMounted, watch } from 'vue'
import * as d3 from 'd3'
import type { RegionData } from '../parse_data.ts'

export default defineComponent({
  name: 'HistogramLegend',
  props: {
    regionData: {
      type: Array as PropType<RegionData[]>,
      required: true
    },
    title: {
      type: String,
      default: undefined
    },
    bins: {
      type: Number,
      default: undefined
    },
    legendMinMax: {
      type: Array as PropType<[number, number]>,
      default: undefined
    }
  },
  setup(props) {
    const container = ref<HTMLElement | null>(null)
    let svg: any = null
    const colorScale = ref(d3.scaleLinear<string>().range(['white', 'red']))
    const regionDataMap = ref(new Map<string, RegionData>())

    const createDataMap = () => {
      regionDataMap.value.clear()

      if (!props.regionData || props.regionData.length === 0) return

      props.regionData.forEach(region => {
        regionDataMap.value.set(region.regionId, region)
      })

      const values = Array.from(regionDataMap.value.values())
        .map(d => d.value)
        .filter((d): d is number => d !== undefined)

      if (values.length === 0) return

      const minValue = props.legendMinMax !== undefined ? props.legendMinMax[0] : d3.min(values)
      const maxValue = props.legendMinMax !== undefined ? props.legendMinMax[1] : d3.max(values)

      if (minValue === undefined || maxValue === undefined) {
        console.warn("Could not determine min/max values for color scale. Check regionData or legendMinMax prop.");
        return;
      }

      colorScale.value = d3.scaleLinear<string>().domain([minValue, maxValue]).range(['white', 'red'])
    }

    const initializeChart = () => {
      if (!container.value) return

      svg = d3.select(container.value)
        .append('svg')
        .attr('width', '100%')
        .attr('height', '150px')
        .attr('viewBox', '0 0 300 150')
        .attr('preserveAspectRatio', 'xMidYMid meet')

      createDataMap()
      updateChart()
    }

    const updateChart = () => {
      if (!svg || regionDataMap.value.size === 0) return

      svg.selectAll('*').remove()
      addPlainLegend()
    }

    const addPlainLegend = () => {
      const legendWidth = 300
      const legendHeight = 150
      const legendMargin = { top: 20, right: 10, bottom: 30, left: 10 }
      const position = { x: 0, y: 0 }

      const legendGroup = svg.append('g')
        .attr('class', 'legend-group')
        .attr('transform', `translate(${position.x}, ${position.y})`)

      if (colorScale.value.domain()[0] === undefined || colorScale.value.domain()[1] === undefined) {
          console.warn("Color scale domain is not set. Cannot render plain legend.");
          return;
      }

      const xScale = d3.scaleLinear()
        .domain(colorScale.value.domain() as [number, number])
        .range([legendMargin.left + 20, legendWidth - legendMargin.right - 10])

      legendGroup.append('text')
        .attr('class', 'legend-title')
        .attr('text-anchor', 'middle')
        .attr('x', legendWidth / 2)
        .attr('y', legendMargin.top + 15)
        .attr('font-size', '14px')
        .attr('font-weight', 'bold')
        .attr('fill', '#333')
        .text(props.title || 'Value Legend')

      const gradientHeight = 20
      const gradientWidth = legendWidth - legendMargin.left - legendMargin.right - 30
      const gradientY = legendMargin.top + 50

      const gradientId = 'color-gradient-' + Math.random().toString(36).substr(2, 9)
      const defs = svg.append('defs')
      const gradient = defs.append('linearGradient')
        .attr('id', gradientId)
        .attr('x1', '0%')
        .attr('y1', '0%')
        .attr('x2', '100%')
        .attr('y2', '0%')

      const colorRange = colorScale.value.range()
      gradient.append('stop')
        .attr('offset', '0%')
        .attr('stop-color', colorRange[0])

      gradient.append('stop')
        .attr('offset', '100%')
        .attr('stop-color', colorRange[1])

      legendGroup.append('rect')
        .attr('x', legendMargin.left + 20)
        .attr('y', gradientY)
        .attr('width', gradientWidth)
        .attr('height', gradientHeight)
        .attr('rx', 4)
        .attr('ry', 4)
        .style('fill', `url(#${gradientId})`)

      const [minValue, maxValue] = colorScale.value.domain() as [number, number];

      const numTicks = 6;
      const whitespace = 8;

      for (let i = 0; i < numTicks; i++) {
        const tickValue = minValue + (maxValue - minValue) * (i / (numTicks - 1));
        const tickX = xScale(tickValue);

        legendGroup.append('text')
          .attr('x', tickX)
          .attr('y', gradientY + gradientHeight + whitespace + 12)
          .attr('text-anchor', 'middle')
          .attr('font-size', '10px')
          .attr('fill', '#555')
          .text(formatTickValue(tickValue));

        legendGroup.append('line')
          .attr('x1', tickX)
          .attr('y1', gradientY + gradientHeight + whitespace)
          .attr('x2', tickX)
          .attr('y2', gradientY + gradientHeight + whitespace + 5)
          .attr('stroke', '#888')
          .attr('stroke-opacity', 0.5);
      }
    }

    const formatNumber = (value: number): string => {
      if (value === 0) {
        return "0";
      }

      const absValue = Math.abs(value);

      if (absValue < 1) {
        if (absValue < 0.0001) {
          return d3.format(".5f")(value);
        } else if (absValue < 0.001) {
          return d3.format(".4f")(value);
        } else if (absValue < 0.01) {
          return d3.format(".3f")(value);
        } else if (absValue < 0.1) {
          return d3.format(".2f")(value);
        } else {
          return d3.format(".1f")(value);
        }
      } else if (absValue < 1000) {
        if (value % 1 === 0) {
          return d3.format(".0f")(value);
        } else {
          return d3.format(".1f")(value);
        }
      } else {
        return d3.format(",.0f")(value);
      }
    };

    const formatLabelValue = (value: number): string => {
      return formatNumber(value);
    }

    const formatTickValue = (value: number): string => {
      return formatNumber(value);
    }

    onMounted(() => {
      initializeChart()
    })

    watch(() => [props.regionData, props.legendMinMax], () => {
      createDataMap()
      updateChart()
    }, { deep: true })

    return {
      container
    }
  }
})
</script>
